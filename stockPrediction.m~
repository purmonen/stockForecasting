clear all;

% Open	High	Low	Close	Volume
allStockPrices = csvread('omx30.csv');

% Move closing price to first index so we won't need to change price index
%allStockPrices = [allStockPrices(:, 4), allStockPrices(:, 1:3), allStockPrices(:, 5:end)];

% Reverse prices so they are in correct order
allStockPrices = allStockPrices(end:-1:1, :);
%allStockPrices = [allStockPrices(:, 1), allStockPrices(:, 5:5)];
allStockPrices = allStockPrices(:, 1);
allStockPrices = allStockPrices(1:1500, 1);

priceIndex = 1;

%allStockPrices = allStockPrices(1:50);
%allStockPrices = (1:200)'.^3;

index = 0;
winner = [0,0,0,0];
totalWinnings = [0,0,0,0];
winnerDuringDecline = [0,0,0,0];

sampleSize = floor(length(allStockPrices) / 16);
%sampleSize = 300;
windowSize = 1;
trainingSize = 50;
validationSize = 0;
while (index+1)*sampleSize <= length(allStockPrices)
    stockPrices = allStockPrices(index*sampleSize+1:(index+1)*sampleSize, :);
    assert(length(stockPrices) == sampleSize)
    
    disp(sprintf('Stock prices %d', index));
    index = index + 1;
    priceChanges = stockPrices(2:end,:) ./ stockPrices(1:end-1,:);
    
    assert(sum(sum(abs(priceChanges .* stockPrices(1:end-1,:) - stockPrices(2:end,:)))) < 0.0001)
    
    normalizedOffset = (max(priceChanges) - min(priceChanges)) / 2 + min(priceChanges);
    normalizedPriceChanges = priceChanges;
    for i = 1:size(priceChanges,2)
       normalizedPriceChanges(:, i) = normalizedPriceChanges(:, i) - normalizedOffset(i);
    end
    normalizedScalar = max(normalizedPriceChanges);
    for i = 1:size(priceChanges,2)
       normalizedPriceChanges(:, i) = normalizedPriceChanges(:, i) / normalizedScalar(i);
    end

    %assert(sum(sum(abs((normalizedPriceChanges * normalizedScalar(1) + normalizedOffset(1)) .* stockPrices(1:end-1,:) - stockPrices(2:end,:)))) < 0.000001)
    %plot([(normalizedPriceChanges * normalizedScalar(1) + normalizedOffset(1)) .* stockPrices(1:end-1,:) stockPrices(2:end) ])
    
    patterns = [];
    targets = [];
    means = [];
    
    for i = 1:size(normalizedPriceChanges,1)-windowSize
        windowPatterns = normalizedPriceChanges(i:i+windowSize-1, :);
        patterns = [patterns, reshape(windowPatterns, numel(windowPatterns),1)];
        
        windowTargets = normalizedPriceChanges(i+windowSize,:);
        targets = [targets, windowTargets];
        
        windowMeans =  mean(normalizedPriceChanges(i:i+windowSize-1, :));
        means = [means, reshape(windowMeans, numel(windowMeans),1)];
    end

    perceptron = MultilayerPerceptron();
    perceptron.plottingEnabled = false;
    perceptron.iterations = 500;
    perceptron.hiddenNodes = 10;
    perceptron.eta = 0.01;
    
    trainingInput = patterns(:, 1:(trainingSize-validationSize));
    trainingOutput = targets(:, 1:(trainingSize-validationSize));
    
    validationInput = patterns(:, (trainingSize-validationSize+1):(trainingSize));
    validationOutput = targets(:, (trainingSize-validationSize+1):(trainingSize));
    
    testInput = patterns(:, (trainingSize+1):end);
    testOutput = targets(:, (trainingSize+1):end);
    
    realPrices = stockPrices(end-length(testOutput)+1:end, priceIndex);
    oneDayBeforeRealPrices = stockPrices(end-length(testOutput):end-1, priceIndex);
    
    %testInput = trainingInput;
    %testOutput = trainingOutput;
    
    %fis2 = anfis([trainingInput' trainingOutput'], [], [], [0 0 0 0], [validationInput' validationOutput'], 0);
    %fis2 = anfis([trainingInput' trainingOutput']);
    
    perceptron.validationPatterns = validationInput;
    perceptron.validationTargets = validationOutput;
    
    %assert(sum(sum(abs((trainingOutput' * normalizedScalar(1) + normalizedOffset(1)) .* stockPrices(windowSize+1:end-1,:) - stockPrices(2+windowSize:end,:)))) < 0.00000001)

    perceptron.train(trainingInput, trainingOutput);
    
    stockPrices = stockPrices(:,priceIndex);
    predictedChanges = perceptron.recall(testInput)' * normalizedScalar(priceIndex) + normalizedOffset(priceIndex);
    
    predictedPrices =  predictedChanges .* oneDayBeforeRealPrices;
    
    getPrediction = @(v) v(end-length(predictedChanges)+1:end);
    meanSize = 1;
    means = getPrediction(arrayfun(@(i) mean(stockPrices(i-meanSize:i-1)), meanSize+1:size(stockPrices,1)))';
    stockPrices = getPrediction(stockPrices);
    
    errPerceptron = sum(sum(abs(predictedPrices - realPrices))) / length(predictedChanges)
    errMeans = sum(sum(abs((means - realPrices)))) / length(predictedChanges)
    figure(1)
    
    plot([stockPrices(end-length(predictedPrices)+1:end) predictedPrices])
    legend('stockPrices', 'predictedPrices')
    
    
    meanPercentageError = @(v) sum(abs(stockPrices - v) ./ stockPrices) / size(stockPrices,1)*100;
    errPerceptron2 = meanPercentageError(predictedPrices)
    errMeans2 = meanPercentageError(means)
    
    %perceptron.plotErrors()
    %for i = 1:size(predictedPrices,2)
    %   predictedPrices(:, i) = (predictedPrices(:, i) + normalizedOffset(i)) * normalizedScalar(i);
    %end

    
    %predictedPricesAnfis = stockPrices(end-length(recallInput):end-1).*(evalfis(recallInput,fis2)*normalizedScalar+normalizedOffset);
    stockPrices = getPrediction(stockPrices);
    
    rootMeanSquareError = @(v) (sum((stockPrices - v).^2) / size(stockPrices,1))^0.5;
    getError2 = @(v) sum(abs(stockPrices - v)) / size(stockPrices,1);
    getErrorValidation = @(v) sum(abs(stockPrices(end-trainingSize:end) - v(end-trainingSize:end)) ...
        ./ stockPrices(end-trainingSize:end)) / size(stockPrices(end-trainingSize:end),1)*100;
    
    predictor = predictedPrices;
    indexes = 1:length(predictor)-1;
    growingIndexes = @(p) indexes(p(indexes+1)' > p(indexes)');
    calculateCash = @(predictedPrices) prod(stockPrices(growingIndexes(predictedPrices)+1) ./ stockPrices(growingIndexes(predictedPrices)));
    
    priceLabels = {'pred'; 'mean'};
    
    prices = [predictedPrices means];
    
    smallestErr = stockPrices(end) / stockPrices(1);
    bestMethods = [4];
    for i=1:length(priceLabels)
        err = calculateCash(prices(:,i));
        totalWinnings(i) = totalWinnings(i) + err;
        if err > smallestErr
            smallestErr = err;
            bestMethods = [i];
        elseif err == smallestErr
            bestMethods = [bestMethods; i];
        end
        disp([strcat(priceLabels{i}, ': Cash')]);
        %disp([meanPercentageError(prices(:,i)) getError2(prices(:,i)) rootMeanSquareError(prices(:,i))])
        disp([calculateCash(prices(:,i))])%
    end
    
    winner(bestMethods) = winner(bestMethods) + 1;
    randomCash = realPrices(end) / realPrices(1)
    if randomCash < 1
        winnerDuringDecline(bestMethods) = winner(bestMethods) + 1;
    end
    totalWinnings(4) = totalWinnings(4) + randomCash;
    
    title('OMX Stockholm 30')
    ylabel('Price')
    xlabel('Day')
    axis tight
    %legend('Real', 'Predicted', 'Least squares', 'Training size')
    set(gcf,'color','w')
    %perceptron.plotErrors()
end

winner
winnings = totalWinnings / index
winnerDuringDecline